# Phase 4 — Wave 4: Dragon vDr unique_ptr; Castle::pDrag non-owning

---
wave: 4
depends_on: ["04-03"]
files_modified:
  - code/game/controller/level_controller.h
  - code/game/controller/level_controller.cc
  - code/game/dragon.h
  - code/game/dragon.cc
  - code/game/critters.h
  - code/game/critters.cc
autonomous: true
---

**Phase:** 4 — Critters, generators, fireball, level  
**CONTEXT:** LevelController::vDr is the single owner of dragons. Castle::pDrag is non-owning (Dragon*). FindDragon returns Dragon* (or optional/similar), not smart_pointer.

**This plan:** Migrate vDr to std::vector<std::unique_ptr<Dragon>>; Castle::pDrag to Dragon*; FindDragon to return Dragon*; update all call sites.

## must_haves (goal-backward verification)

- [ ] LevelController::vDr is std::vector<std::unique_ptr<Dragon>>. Init creates Dragon with std::make_unique<Dragon>(...) and vDr.push_back(std::move(...)). Dragons are not in base lsDraw/lsUpdate with ownership — expose via GetNonOwnedUpdateEntities/GetNonOwnedDrawEntities (pointers from vDr).
- [ ] Castle::pDrag is Dragon* (non-owning). When dragon lands, pCs->pDrag = pAd->FindDragon(this) (FindDragon returns Dragon*). When dragon takes off, pCs->pDrag = nullptr (or leave as dangling until next land — document; safer to set nullptr). No smart_pointer or unique_ptr in Castle.
- [ ] FindDragon(Dragon* p) returns Dragon* (or nullptr). Implementation: iterate vDr, compare .get() to p; return matching .get().
- [ ] All call sites that used smart_pointer<Dragon> (e.g. pAd->FindDragon(this) returning a ref for assignment to pDrag) updated to use Dragon*. Where a shared reference was stored, store raw pointer only.
- [ ] SP_Info removed from Dragon if no smart_pointer remains (CLEAN-01).
- [ ] Build succeeds; ctest and simulation_test pass (VER-01, VER-02).

---

## Task 1 — vDr unique_ptr; FindDragon returns Dragon*

1. In `level_controller.h`: Change `std::vector<smart_pointer<Dragon>> vDr` to `std::vector<std::unique_ptr<Dragon>> vDr`. FindDragon declaration: `Dragon* FindDragon(Dragon* p);` (return raw pointer or nullptr).
2. In `level_controller.cc` Init: vDr.push_back(std::make_unique<Dragon>(...)). After push_back, set vDr.back()->pCs->pDrag = vDr.back().get() (not smart_pointer). Ensure GetNonOwnedUpdateEntities and GetNonOwnedDrawEntities include pointers from vDr (for each dragon, push_back(vDr[i].get())).
3. In `level_controller.cc`: Implement FindDragon: for (auto& u : vDr) { if (u.get() == p) return u.get(); } return nullptr; (or equivalent). Update any code that assumed FindDragon returned smart_pointer (e.g. assignment to pDrag) to assign the raw pointer.
4. Update all uses of vDr (e.g. vDr[0]->, vDr[i]->) to use .get() where a pointer is needed, or keep as vDr[i]-> for operator->. Build and ctest; simulation_test.

---

## Task 2 — Castle::pDrag to Dragon*; call sites

1. In `critters.h` Castle: Change `smart_pointer<Dragon> pDrag` to `Dragon* pDrag`. Initialize to nullptr in ctor or where Castle is created.
2. In `critters.cc` and `dragon.cc`: Where pCs->pDrag is assigned (e.g. pAd->FindDragon(this)), assign Dragon* only. Where pDrag is checked (e.g. pDrag.is_null()), use (pDrag == nullptr). Where pDrag is dereferenced (pDrag->...), unchanged. When dragon takes off (Dragon::Toggle), set pCs->pDrag = nullptr before pCs = nullptr.
3. In `level_controller.cc`: BonusDrawer and any code iterating vDr and accessing dragons — use vDr[i].get() or vDr[i]-> as needed. Build and ctest; simulation_test.
4. Remove SP_Info from Dragon if no smart_pointer use remains. Build and ctest; simulation_test.

---

## Verification

- Build and ctest; simulation_test.
- Grep for smart_pointer<Dragon> — none in level_controller, critters, dragon.
