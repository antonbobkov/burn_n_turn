---
phase: 04-critters-generators-fireball-level
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - code/game/controller/level_controller.h
  - code/game/controller/level_controller.cc
  - code/game/dragon.cc
  - code/game/critters.h
  - code/game/critters.cc
autonomous: true

must_haves:
  truths:
    - "LevelController owns dragons in vDr as unique_ptr; Castle holds non-owning Dragon*"
    - "FindDragon returns Dragon*; no smart_pointer<Dragon> at call sites"
  artifacts:
    - path: code/game/controller/level_controller.h
      provides: vDr as vector<unique_ptr<Dragon>>; FindDragon returns Dragon*
    - path: code/game/critters.h
      provides: Castle::pDrag as Dragon*
  key_links:
    - from: level_controller.cc Init
      to: vDr.back()->pCs->pDrag = vDr.back().get()
      via: assign raw ptr after push_back
    - from: critters.cc / dragon.cc
      to: pDrag checks and assignment
      via: nullptr and raw ptr (no .is_null())
---

<objective>
Migrate LevelController::vDr to vector of unique_ptr; Castle::pDrag to
Dragon* (non-owning). FindDragon returns Dragon*. All Init and call sites use
vDr[i].get() and raw ptr semantics. Remove smart_pointer<Dragon> from codebase
for this ownership path.

Purpose: Single owner for Dragon at LevelController; Castle and others hold
Dragon* per CONTEXT.
Output: vDr unique_ptr; pDrag Dragon*; FindDragon returns Dragon*; build and tests pass.
</objective>

<execution_context>
@~/.cursor/get-shit-done/workflows/execute-plan.md
@~/.cursor/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-critters-generators-fireball-level/04-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: vDr to unique_ptr; Init and pDrag assignment</name>
  <files>code/game/controller/level_controller.h, code/game/controller/level_controller.cc</files>
  <action>
    In level_controller.h: change std::vector&lt;smart_pointer&lt;Dragon&gt;&gt; vDr to std::vector&lt;std::unique_ptr&lt;Dragon&gt;&gt; vDr. In level_controller.cc Init: where dragons are created use std::make_unique&lt;Dragon&gt;(...) and vDr.push_back(std::move(...)); set vDr.back()-&gt;pCs-&gt;pDrag = vDr.back().get(). Remove AddBoth(vDr[i]); dragons are exposed via GetNonOwnedUpdateEntities/GetNonOwnedDrawEntities (append vDr[i].get() for each dragon). Update every use of vDr[i] that expects a pointer to use vDr[i].get() where a Dragon* is required; keep vDr[i] for unique_ptr access (e.g. vDr[i]-&gt;RecoverBonuses() is fine via operator-&gt;). FindDragon: change return type from smart_pointer&lt;Dragon&gt; to Dragon*; return vDr[i].get() for the matching dragon or nullptr.
  </action>
  <verify>cd build; mingw32-make; cd ../bin; .\simulation_test.exe</verify>
  <done>vDr is vector of unique_ptr; FindDragon returns Dragon*; Init assigns pDrag = vDr.back().get().</done>
</task>

<task type="auto">
  <name>Task 2: Castle::pDrag to Dragon*; update all call sites</name>
  <files>code/game/critters.h, code/game/critters.cc, code/game/dragon.cc</files>
  <action>
    In critters.h: change smart_pointer&lt;Dragon&gt; pDrag to Dragon* pDrag. In critters.cc: replace pDrag = smart_pointer&lt;Dragon&gt;() with pDrag = nullptr; replace !pDrag.is_null() with pDrag != nullptr (or if (pDrag)); all pDrag-&gt;... calls unchanged. In dragon.cc: pCs-&gt;pDrag = pAd-&gt;FindDragon(this) stays (FindDragon now returns Dragon*); pCs-&gt;pDrag = smart_pointer&lt;Dragon&gt;() becomes pCs-&gt;pDrag = nullptr; if (!pAd-&gt;vCs[i]-&gt;pDrag.is_null()) becomes if (pAd-&gt;vCs[i]-&gt;pDrag != nullptr). Remove smart_pointer include from critters.h if no longer needed for Castle. Remove SP_Info from Dragon if no smart_pointer&lt;Dragon&gt; remains.
  </action>
  <verify>cd build; mingw32-make; cd ../bin; .\simulation_test.exe</verify>
  <done>pDrag is Dragon* everywhere; all null checks use nullptr; build and tests pass.</done>
</task>

</tasks>

<verification>
Build and ctest; simulation_test.exe. Grep for smart_pointer&lt;Dragon&gt; (expect none in level/critters path). GetNonOwned* includes vDr[].get().
</verification>

<success_criteria>
- vDr is vector&lt;unique_ptr&lt;Dragon&gt;&gt;; Castle::pDrag is Dragon*.
- FindDragon returns Dragon*; all call sites use raw ptr.
- Build and all tests pass.
</success_criteria>

<output>
After completion, create .planning/phases/04-critters-generators-fireball-level/04-critters-generators-fireball-level-04-SUMMARY.md
</output>
