# Phase 4 — Wave 3: TimedFireballBonus; carry-over handoff fix

---
wave: 3
depends_on: ["04-02"]
files_modified:
  - code/game/dragon.h
  - code/game/dragon.cc
  - code/game/controller/level_controller.h
  - code/game/controller/level_controller.cc
  - code/game/controller/dragon_game_controller.h
  - code/game/controller/dragon_game_controller.cc
  - code/game/fireball.h
  - code/game/fireball.cc
autonomous: true
---

**Phase:** 4 — Critters, generators, fireball, level  
**CONTEXT:** Dragon::lsBonuses owns TimedFireballBonus; level must not store in lsUpdate — LevelController returns pointers via GetNonOwnedUpdateEntities (and GetNonOwnedDrawEntities if drawn). Carry-over: handoff by move on first Update (RecoverBonuses then Clear); do not clear in Dragon ctor before RecoverBonuses.

**This plan:** Migrate TimedFireballBonus to unique_ptr at Dragon and DGC; AddBonus no longer calls AddE; LevelController GetNonOwned* includes dragon bonuses; fix handoff order (RecoverBonuses then Clear; remove clear from Dragon ctor).

## must_haves (goal-backward verification)

- [ ] Dragon::lsBonuses is std::list<std::unique_ptr<TimedFireballBonus>>. Dragon::AddBonus takes std::unique_ptr<TimedFireballBonus> and push_back(std::move(p)); does not call pAd->AddE(pBonus). LevelController::GetNonOwnedUpdateEntities (and GetNonOwnedDrawEntities if bonuses are drawn) returns pointers from all dragons’ lsBonuses so base loop updates/draws them.
- [ ] DragonGameController::lsBonusesToCarryOver is std::list<std::unique_ptr<TimedFireballBonus>>. AddBonusToCarryOver takes std::unique_ptr and move. GetBonusesToCarryOver returns const reference to the list (or a view). RecoverBonuses moves from that list into Dragon::lsBonuses; then ClearBonusesToCarryOver clears the list. Dragon ctor does not call ClearBonusesToCarryOver so that RecoverBonuses (on first Update) runs first and gets the bonuses.
- [ ] FlushBonuses: for each bonus in lsBonuses, move it to DGC via AddBonusToCarryOver(std::move(*itr)); then remove from lsBonuses (or clear lsBonuses). So ownership transfers to DGC on level win.
- [ ] SP_Info removed from TimedFireballBonus (and CircularFireball etc.) where no smart_pointer remains (CLEAN-01).
- [ ] Build succeeds; ctest and simulation_test pass (VER-01, VER-02).

---

## Task 1 — Dragon::lsBonuses unique_ptr; no AddE; LevelController GetNonOwned* for bonuses

1. In `dragon.h`: Change `std::list<smart_pointer<TimedFireballBonus>> lsBonuses` to `std::list<std::unique_ptr<TimedFireballBonus>> lsBonuses`. AddBonus signature: `void AddBonus(std::unique_ptr<TimedFireballBonus> pBonus, bool bSilent = false)`.
2. In `dragon.cc`: AddBonus: take unique_ptr, push_back(std::move(pBonus)). Remove pAd->AddE(pBonus). GetAllBonuses: adapt to unique_ptr list (CleanUp erases where !bExist; iterate and aggregate). FlushBonuses: for each element, call pAd->pGl->AddBonusToCarryOver(std::move(*itr)); then erase from lsBonuses or clear. RecoverBonuses: get const ref to DGC list; for each, AddBonus(std::make_unique<TimedFireballBonus>(*itr)) or move if DGC gives up ownership (see Task 2). If DGC returns ref and RecoverBonuses copies, then after RecoverBonuses, DGC clears the list (no move). Per CONTEXT, handoff by move: RecoverBonuses should take ownership (DGC gives unique_ptrs to Dragon); then ClearBonusesToCarryOver.
3. In `level_controller.cc`: GetNonOwnedUpdateEntities (and GetNonOwnedDrawEntities): append pointers from each vDr[i]->lsBonuses (iterate and push_back(.get())). So base Update/draw loop runs bonuses without owning them.
4. In `level_controller.cc` BonusDrawer (or wherever dragon bonuses are drawn): already iterates vDr[nDr]->lsBonuses; ensure it uses raw pointers. Build and ctest; simulation_test.

---

## Task 2 — Carry-over: unique_ptr; handoff RecoverBonuses then Clear; no clear in Dragon ctor

1. In `dragon_game_controller.h`: Change `std::list<smart_pointer<TimedFireballBonus>> lsBonusesToCarryOver` to `std::list<std::unique_ptr<TimedFireballBonus>> lsBonusesToCarryOver`. AddBonusToCarryOver(std::unique_ptr<TimedFireballBonus> b). GetBonusesToCarryOver() returns const std::list<std::unique_ptr<TimedFireballBonus>>& (or a view).
2. In `dragon_game_controller.cc`: AddBonusToCarryOver: lsBonusesToCarryOver.push_back(std::move(b)). ClearBonusesToCarryOver: lsBonusesToCarryOver.clear().
3. In `dragon.cc` Dragon::Dragon ctor: Remove the line pAd->pGl->ClearBonusesToCarryOver(). So the list is not cleared when the new dragon is created.
4. In `dragon.cc` RecoverBonuses: Get list from pAd->pGl->GetBonusesToCarryOver(). For each unique_ptr in that list, move into Dragon: e.g. take ownership by swapping/moving into lsBonuses (DGC list must allow move-out; if API is const ref, you need a method like DGC::TakeBonusesToCarryOver() that returns the list by move, then Dragon pushes those into lsBonuses and DGC clears). Implement so that RecoverBonuses moves all bonuses from DGC into Dragon, then LevelController::Update (first tick) calls pGl->ClearBonusesToCarryOver() after RecoverBonuses.
5. In `level_controller.cc` Update (bFirstUpdate): Keep order: vDr[0]->RecoverBonuses(); then pGl->ClearBonusesToCarryOver(); so handoff happens before clear.
6. FlushBonuses (level win): Dragon gives ownership to DGC — AddBonusToCarryOver(std::move(*itr)); then erase from lsBonuses. Build and ctest; simulation_test.

---

## Verification

- Build and ctest; simulation_test.
- Confirm Dragon ctor does not call ClearBonusesToCarryOver. Confirm first Update calls RecoverBonuses then ClearBonusesToCarryOver.
- Grep for smart_pointer<TimedFireballBonus> — none in dragon, level_controller, dragon_game_controller.
