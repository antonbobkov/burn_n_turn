# Phase 4 — Wave 2: Fireball level-owned; remove Dragon::lsBalls

---
wave: 2
depends_on: ["04-01"]
files_modified:
  - code/game/dragon.h
  - code/game/dragon.cc
  - code/game/fireball.h
  - code/game/fireball.cc
  - code/game/controller/level_controller.h
  - code/game/controller/level_controller.cc
autonomous: true
---

**Phase:** 4 — Critters, generators, fireball, level  
**CONTEXT:** Level owns all fireballs. Delete Dragon::lsBalls. Level stores fireballs in level-owned storage (e.g. owned_entities or a dedicated list) and runs update/draw via existing loop or GetNonOwned*.

**This plan:** Fireball created by Dragon or in fireball.cc (chain) is given to LevelController; LevelController owns it. Remove Dragon::lsBalls and all references.

## must_haves (goal-backward verification)

- [ ] Dragon no longer has lsBalls. Dragon::Fire() creates Fireball with make_unique and gives ownership to level (e.g. LevelController::AddFireball(std::unique_ptr<Fireball>) or AddOwnedBoth(std::move(pFb))); no second list on Dragon. Remove CleanUp(lsBalls) and the lsBalls.push_back branch.
- [ ] Chain fireballs in fireball.cc (Fireball::Update): Create with make_unique and give to level (pBc->AddFireball(std::move(pFb)) or equivalent); level owns them. Same for KnightOnFire, ChainExplosion if they are owned by level.
- [ ] LevelController (or base) holds fireballs in a single owning container; CleanUp removes dead fireballs. No duplicate ownership.
- [ ] SP_Info removed from Fireball (and related types) where no smart_pointer remains (CLEAN-01).
- [ ] Build succeeds; ctest and simulation_test pass (VER-01, VER-02).

---

## Task 1 — LevelController owns fireballs; AddFireball (or AddOwnedBoth)

1. In `level_controller.h`: Add a method to take ownership of a Fireball, e.g. `void AddFireball(std::unique_ptr<Fireball> p);` and a container, e.g. `std::list<std::unique_ptr<Fireball>>` or use EntityListController::AddOwnedBoth with unique_ptr<Fireball>. If using owned_entities pattern, AddOwnedBoth(p) stores in owned_entities and registers for draw/update. Ensure CleanUp in Update() removes dead fireballs from that container.
2. In `level_controller.cc`: Implement AddFireball (or use AddOwnedBoth) and ensure fireballs are updated and drawn (owned_entities are already updated/drawn in basic_controllers.cc; if using a separate list, add pointers to GetNonOwnedUpdateEntities/GetNonOwnedDrawEntities and CleanUp that list in Update).

---

## Task 2 — Dragon: remove lsBalls; give fireball to level only

1. In `dragon.h`: Remove `std::list<smart_pointer<Fireball>> lsBalls` and any include that was only for it.
2. In `dragon.cc` Dragon::Fire(): Remove CleanUp(lsBalls). Create fireball with std::make_unique<Fireball>(...). Call pAd->AddFireball(std::move(pFb)) (or pAd->AddOwnedBoth(std::move(pFb))) for each fireball; remove the block that did lsBalls.push_back(pFb) for the middle shot.
3. In `fireball.cc`: Where new Fireball is created (chain), use std::make_unique<Fireball>(...) and pBc->AddFireball(std::move(pFb)) (or AddOwnedBoth). Same for KnightOnFire and ChainExplosion if they are added via AddBoth — migrate to level-owned (AddOwnedBoth or level-owned list). Update all make_smart(new Fireball(...)) and pBc->AddBoth(pFb) to the new pattern.
4. Remove SP_Info from Fireball (and related) if no smart_pointer use remains. Build and ctest; simulation_test.

---

## Verification

- Build and ctest; simulation_test.
- Grep for lsBalls and smart_pointer<Fireball> in dragon — none. Fireball ownership only in level.
