# Phase 3 — Task 1.2: DGC StartUp (remaining work)

---
wave: 1
depends_on: []
files_modified:
  - code/game/entities.h
  - code/game/entities.cc
  - code/game/controller/dragon_game_controller.cc
  - code/game/controller/menu_controller.h
  - code/game/controller/menu_controller.cc
autonomous: false
---

**Phase:** 3 — Game entities and animations  
**Scope:** Task 1.2 only. All other Phase 3 work is done (see 03-03-SUMMARY.md).

**Goal:** Complete DragonGameController::StartUp migration so that shared
objects (logo, burn, SoundControls) are passed **by value (copies)** and
each controller **owns** its copy; single-use entities created with
make_unique and added via AddOwned*.

**Context:** 03-CONTEXT.md, 03-01.2-RESOLUTION-OPTIONS.md. No list/AddV/AddE
redesign; simple controllers do not override GetNonOwned*.

## must_haves (goal-backward verification)

- [ ] StaticImage and Animation are copyable (audited/implemented); logo
  and burn created once, copies passed to pCnt1, pMenu, pBuy; each
  controller owns its copy via AddOwned*.
- [ ] SoundControls is copyable; a copy is passed to each controller that
  needs pBckgMusic or pNoMusic; each controller owns its copy via
  AddOwnedEventEntity (or AddOwnedBoth).
- [ ] All other StartUp leaf entities (pTrial, pBuyNow, pWin, pGolem,
  pSkeleton1–3, pMage, pGhost, pWhiteKnight, pHintText, pOptionText, pO,
  pPlu, pGen, pOver, pPluSnd, pClkSnd, pSlimeUpd) created with
  make_unique and added via AddOwned* to the controller that owns them;
  no smart_pointer in StartUp for these.
- [ ] MenuDisplay: MenuController owns via explicit std::unique_ptr
  (not AddOwnedBoth); included in draw/update via GetNonOwned*
  overrides.
- [ ] Build succeeds; ctest and simulation_test pass (VER-01, VER-02).
  Both TRIAL_VERSION and FULL_VERSION builds tested.

---

## StartUp entity checklist (owner and registration)

Use this to avoid wrong ownership. **By value** = create once (or one
template), then make a copy per consumer; **controller owns** = that
controller gets the unique_ptr via AddOwned*.

| Entity | Current | Owner (after) | Registration |
|--------|---------|----------------|---------------|
| pBckgMusic (SoundControls) | make_smart, AddE to pCnt1, pAd, each LevelController | **By value:** each of pCnt1, each LevelController, pAd | AddOwnedEventEntity(copy) per controller |
| pNoMusic (SoundControls) | make_smart, AddE to pMenu, pCut1–3, pCnt2, pCnt3 | **By value:** each of pMenu, pCut1, pCut2, pCut3, pCnt2, pCnt3 | AddOwnedEventEntity(copy) per controller |
| pL (logo StaticImage) | make_smart, AddV/AddBoth to pCnt1, pMenu, pBuy | **By value:** pCnt1, pMenu, pBuy each own a copy | AddOwnedVisualEntity(copy) or AddOwnedBoth(copy) per controller |
| pBurnL, pBurnR (Animation) | make_smart, AddBoth to pCnt1, pMenu, pBuy | **By value:** pCnt1, pMenu, pBuy each own copies | AddOwnedBoth(copy) per controller |
| pTrial (StaticImage) | make_smart, AddV to pCnt1 | pCnt1 | AddOwnedVisualEntity; **#ifdef TRIAL_VERSION** only (Task 4c). |
| pBuyNow (StaticImage) | make_smart, AddV to pBuy | pBuy | AddOwnedVisualEntity; **#ifdef TRIAL_VERSION** only (Task 4c). |
| pWin (Animation) | make_smart, AddBoth to pCnt3 | pCnt3 | AddOwnedBoth(make_unique<...>) |
| pHintText, pOptionText (TextDrawEntity) | make_smart; PC: pMenu refs; !PC: pCnt1 AddV(pHintText) | **PC_VERSION:** pMenu owns both. **!PC_VERSION:** pCnt1 owns pHintText. | PC: transfer to pMenu (setters/owners). !PC: AddOwnedVisualEntity(pHintText) to pCnt1. |
| pO, pPlu, pGen (AnimationOnce) | make_smart, AddBoth/AddE to pCnt2, pCnt0_1, pCnt0_2 | pCnt2 (pO), pCnt0_1 (pPlu), pCnt0_2 (pGen) | AddOwnedBoth per controller |
| pOver, pPluSnd, pClkSnd (SimpleSoundEntity) | make_smart, AddE to pCnt2, pCnt0_1, pCnt0_2 | pCnt2, pCnt0_1, pCnt0_2 | AddOwnedEventEntity or AddOwnedBoth; pass pSnd.get() from DGC (already done) |
| pGolem, pSkeleton1–3, pMage, pGhost, pWhiteKnight (Animation) | make_smart, AddBoth to pBuy | pBuy | AddOwnedBoth each; **#ifdef TRIAL_VERSION** only (Task 4c). |
| pSlimeUpd (SlimeUpdater) | make_smart(new SlimeUpdater(pBuy.get())) | pBuy | AddOwned*; pBuy.get() raw for ctor; **#ifdef TRIAL_VERSION** only (Task 4c). |
| pStr (Animation) | make_smart, AddBoth to pCnt1 | pCnt1 | AddOwnedBoth(make_unique<...>) — Task 4. Caret already done (Task 1.3). |
| pMenuDisplay (MenuDisplay) | make_unique in DGC, AddOwnedBoth to pMenu | **MenuController** | **Task 5:** Explicit std::unique_ptr in MenuController; do **not** use AddOwnedBoth. Include in GetNonOwnedDrawEntities and GetNonOwnedUpdateEntities so base loop draws/updates it. |

Note: LevelController::pSc — with by-value, each LevelController owns its copy of SoundControls. Set pSc to the raw pointer of that owned copy (e.g. when adding via AddOwnedEventEntity, capture the raw pointer and assign to pSc in Init or after creation).

---

## Task 1 — Copyability (StaticImage, Animation, SoundControls)

1. In `code/game/entities.h` / `entities.cc`: Audit StaticImage, Animation,
   SoundControls for copyability (copy ctor, assign; no non-copyable
   members). Add or fix copy constructors (and copy assign if needed) so
   that a copy can be passed to a controller and stored via
   AddOwned*(std::make_unique<T>(original)) or equivalent.
2. If any type cannot be copied safely (e.g. holds raw resource), document
   and use multiple instances (create N copies with make_unique) instead
   of one original + copy ctor.
3. Build and run ctest; run simulation_test.

---

## Task 2 — SoundControls by value

1. In `dragon_game_controller.cc` StartUp: Remove DGC-owned
   make_smart(SoundControls) for pBckgMusic and pNoMusic.
2. For each controller that needs background music (pCnt1, each
   LevelController, pAd): create a **copy** of SoundControls (e.g. from
   a local template: `SoundControls bckg(plr, BG_BACKGROUND)` then
   `pCnt1->AddOwnedEventEntity(std::make_unique<SoundControls>(bckg))`;
   or create with make_unique and pass params). Each such controller
   owns one copy.
3. For each controller that needs pNoMusic (pMenu, pCut1, pCut2, pCut3,
   pCnt2, pCnt3): same pattern — create a copy and
   AddOwnedEventEntity(std::make_unique<SoundControls>(noMusic_template)).
4. LevelController: set pSc to the SoundControls* that this controller
   owns (e.g. the raw pointer from the entity added via AddOwned*; may
   require storing that pointer in LevelController or obtaining it from
   the owned list). See level_controller.h for pSc usage.
5. Remove all AddE(pBckgMusic) / AddE(pNoMusic) and replace with the
   per-controller owned copy above.
6. Build and run ctest; run simulation_test. Test TRIAL and FULL.

---

## Task 3 — Logo and burn by value (2A)

1. In StartUp: Create one logo (StaticImage) and two burn animations
   (Animation) as local variables or with make_unique then copy.
2. For pCnt1: AddOwnedVisualEntity(std::make_unique<StaticImage>(logo));
   AddOwnedBoth(std::make_unique<Animation>(burnL)); same for burnR.
3. For pMenu: same — two copies of logo, burnL, burnR via AddOwned*.
4. For pBuy (TRIAL_VERSION): same — two copies of logo, burnL, burnR via
   AddOwned*.
5. Remove all AddV(pL), AddBoth(pBurnL), AddBoth(pBurnR) and the
   make_smart(pL), make_smart(pBurnL), make_smart(pBurnR). No shared
   smart_pointer.
6. Build and run ctest; run simulation_test. Test TRIAL and FULL.

---

## Task 4a — Unconditional StartUp entities (no macro conditionals)

Entities that exist in all builds. Migrate to make_unique + AddOwned*.
Do **not** wrap these in #ifdef; the controllers (pCnt1, pCnt2, pCnt3,
pCnt0_1, pCnt0_2) exist unconditionally.

1. **pStr (Animation):** pCnt1 owns. Create with make_unique; add via
   pCnt1->AddOwnedBoth(...). Remove make_smart(pStr) and AddBoth(pStr).
2. **pWin:** pCnt3 owns. make_unique; pCnt3->AddOwnedBoth(...).
3. **pO, pOver:** pCnt2 owns. make_unique; pCnt2->AddOwnedBoth(pO);
   AddOwnedEventEntity(pOver). pOver already receives pSnd.get() from DGC.
4. **pPlu, pPluSnd:** pCnt0_1 owns. make_unique; AddOwnedBoth(pPlu);
   AddOwnedEventEntity(pPluSnd).
5. **pGen, pClkSnd:** pCnt0_2 owns. make_unique; AddOwnedBoth(pGen);
   AddOwnedEventEntity(pClkSnd).
6. **pHintText, pOptionText:** Ownership depends on **#ifdef PC_VERSION.**
   - **#ifdef PC_VERSION:** MenuController (pMenu) owns both. Create
     with make_unique in StartUp and transfer to pMenu (e.g. setter
     pMenu->SetHintText(std::move(pHintText)) and SetOptionText(std::move
     (pOptionText)); or assign to pMenu’s owning members). pMenu draws
     them (menu_controller.cc). Do not add to pCnt1.
   - **#else:** pCnt1 owns pHintText only. Create with make_unique;
     pCnt1->AddOwnedVisualEntity(std::move(pHintText)). pOptionText is
     not used on the start screen in this branch; create and add to
     pCnt1 if it is displayed elsewhere, or omit if unused.
7. Remove make_smart and AddV/AddE/AddBoth for the above. Build and run
   ctest; run simulation_test.

---

## Task 4c — TRIAL_VERSION-only entities (pTrial, pBuy and its entities)

All of this block must stay inside **#ifdef TRIAL_VERSION** so it only
compiles in trial builds.

1. **pTrial (StaticImage):** pCnt1 owns. Inside **#ifdef TRIAL_VERSION**,
   create with make_unique; pCnt1->AddOwnedVisualEntity(std::move(pTrial)).
   Remove the existing #ifdef TRIAL_VERSION block that does make_smart and
   AddV(pTrial); replace with the make_unique + AddOwned* version.
2. **pBuy (BuyNowController):** Leave pBuy creation as-is (make_smart;
   controller migration is separate). Only the **entities** added to pBuy
   are migrated below.
3. **pBuy-owned entities (TRIAL only):** Inside the same **#ifdef
   TRIAL_VERSION** block, create in order:
   - pGolem, pSkeleton1, pSkeleton2, pSkeleton3, pMage, pGhost,
     pWhiteKnight (Animation): each with make_unique; pBuy->AddOwnedBoth(...)
     for each.
   - pBuyNow (StaticImage): make_unique; pBuy->AddOwnedVisualEntity(...).
   - pSlimeUpd (SlimeUpdater): make_unique(new SlimeUpdater(pBuy.get()));
     pBuy->AddOwnedEventEntity or AddOwnedBoth (SlimeUpdater is VisualEntity
     and/or EventEntity). SlimeUpdater ctor takes BuyNowController* (raw);
   - Logo and burn copies for pBuy are already done in Task 3 (by value).
4. **vCnt and pBuy:** The existing **#ifdef FULL_VERSION** / **#else**
   block pushes either (pCnt3, pCnt2, pScore) or (pCnt2, pBuy). Leave that
   logic unchanged; only ensure pBuy and its entities are created and
   added inside #ifdef TRIAL_VERSION so that in the #else branch pBuy
   exists when pushed.
5. Remove every make_smart in the TRIAL block; replace with make_unique
   and AddOwned* as above. Build and run ctest; run simulation_test.
   **Test both TRIAL_VERSION and FULL_VERSION builds.**

---

## Task 5 — MenuDisplay: explicit unique_ptr in MenuController, GetNonOwned*

MenuDisplay must be owned by MenuController via an **explicit**
std::unique_ptr. It must **not** be added via AddOwnedBoth. It must be
drawn and updated via MenuController’s GetNonOwned* overrides (same
pattern as the caret).

1. In `menu_controller.h`: Change pMenuDisplay to
   `std::unique_ptr<MenuDisplay> pMenuDisplay` (owning). Remove any raw
   pointer type; MenuController owns the object.
2. In `menu_controller.cc`: In GetNonOwnedDrawEntities and
   GetNonOwnedUpdateEntities, include pMenuDisplay (e.g. if non-null,
   add pMenuDisplay.get() to the returned vector) so the base
   EntityListController draw/update loop draws and updates MenuDisplay.
   Ensure Update(), Next(), OnKey, etc. use pMenuDisplay with null checks
   as needed.
3. In `dragon_game_controller.cc` StartUp: Either (A) have MenuController
   create and own MenuDisplay (e.g. in ctor or Init, with args passed from
   StartUp), or (B) keep creating it in StartUp with std::make_unique and
   transfer ownership to MenuController via a setter (e.g.
   pMenu->SetMenuDisplay(std::move(pMenuDisplay))). In both cases do
   **not** call pMenu->AddOwnedBoth(pMenuDisplay). Remove the existing
   AddOwnedBoth(std::move(pMenuDisplay)) and the assignment
   pMenu->pMenuDisplay = pMenuDisplay.get(); MenuController stores the
   unique_ptr and exposes the raw pointer for call sites that need it.
4. Any other code that sets or uses pMenu->pMenuDisplay (e.g.
   UpdateMenuEntries) continues to use the raw pointer from
   pMenuDisplay.get() or the member; no change except ownership lives
   in MenuController.
5. Build and run ctest; run simulation_test. Test TRIAL and FULL.

---

## Verification (after each task or logical group)

- From project root (code): `cd build; mingw32-make`. Build must succeed.
- `ctest --output-on-failure` from build. All tests pass (VER-01).
- `cd bin; .\simulation_test.exe`. simulation_test passes (VER-02).
- Build and run with TRIAL_VERSION and FULL_VERSION if both exist.

---

## PLANNING COMPLETE

Task 1.2 remaining: (1) Copyability. (2) SoundControls by value. (3) Logo
and burn by value. (4a) Unconditional entities (pStr, pWin, pO, pOver,
pPlu, pPluSnd, pGen, pClkSnd, pHintText, pOptionText; respect
PC_VERSION for menu refs). (4c) TRIAL_VERSION-only (pTrial, pBuy and
pBuyNow, pSlimeUpd, pGolem, pSkeleton1–3, pMage, pGhost, pWhiteKnight).
(5) MenuDisplay: explicit unique_ptr in MenuController; GetNonOwned*.
