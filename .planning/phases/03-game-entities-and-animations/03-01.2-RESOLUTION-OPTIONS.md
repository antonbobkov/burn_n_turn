# Task 1.2 (DGC StartUp) — Resolution options

**Purpose:** Brainstorm ways to resolve the blockers that caused Task 1.2 to be
deferred. Use this to pick an approach before a follow-up plan or execution.

Context: 03-03-SUMMARY.md "Why Task 1.2 was deferred"; 03-CONTEXT.md (ownership
decisions already fixed).

---

## 1. AddV / AddE and list types (core blocker)

**Problem:** `AddV`/`AddE` take `smart_pointer<...>`; `lsDraw`/`lsUpdate` are
`std::list<smart_pointer<...>>`. To pass raw pointers (DGC-owned SoundControls,
logo/burn copies, etc.) we need a way to register non-owned entities for
draw/update.

**Options:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **1A. Raw lists + raw overloads** | Change `lsDraw`/`lsUpdate` to `std::list<VisualEntity*>` / `std::list<EventEntity*>`; add `AddV(VisualEntity*)`, `AddE(EventEntity*)`; all call sites pass `.get()` or raw; owners keep `unique_ptr` elsewhere. | Single list type; no refcount in lists; clear "owner elsewhere, list is non-owning." | Touches every caller (Phase 3 and 4); must remove all `smart_pointer` from these lists in one go; `CleanUp` stays "erase only" (no delete). |
| **1B. Non-owned lists alongside existing** | Keep `lsDraw`/`lsUpdate` as-is. Add `lsDrawNonOwned`, `lsUpdateNonOwned` (raw pointer lists) and `AddVNonOwned(VisualEntity*)`, `AddENonOwned(EventEntity*)`. In `Update()`, iterate both owned + non-owned for draw/update; `CleanUp` only erases from non-owned (never delete). | Backward compatible; Phase 4 can keep using `AddV`/`AddE` with smart_pointer until migrated; DGC can use Add*NonOwned for SoundControls, etc. | Two list pairs; two code paths in Update; need to document "non-owned = never delete." |
| **1C. Overloads that push raw into same list** | Add overloads `AddV(VisualEntity*)` / `AddE(EventEntity*)` that push the raw pointer into **the same** `lsDraw`/`lsUpdate` by wrapping in a smart_pointer that does **not** own (e.g. "non-owning" or "observer" wrapper). | Single loop in Update; callers can pass raw. | Requires a non-owning smart_pointer variant or a new wrapper type; mixes owning and non-owning semantics in one list; error-prone. |
| **1D. Only GetNonOwned* for DGC-owned** | Don't change lists. Each controller that needs to show DGC-owned entities (SoundControls, logo/burn copies) overrides `GetNonOwnedDrawEntities` / `GetNonOwnedUpdateEntities` and returns those pointers. DGC (or a small helper) would need to tell each controller which raw ptrs to return. | No change to `AddV`/`AddE` or list types; reuses existing pattern (like MenuController + caret). | Many controllers (pCnt1, pMenu, pBuy, pCut1–3, pCnt2, pCnt3, every LevelController) must override and know their "non-owned" set; wiring and duplication; easy to forget one. |

**Recommendation:** **1A** gives the cleanest long-term design (single owner, raw in lists). **1B** is the least disruptive short-term and unblocks Task 1.2 without touching Phase 4 call sites yet.

**Chosen:** **1D for MenuController only.** Only MenuController (and LevelController for tutorial text) override GetNonOwned*. Simple controllers must **not** override GetNonOwned*; they receive copies and own them (see §2, §3).

---

## 2. Option C (logo and burn "by value")

**Problem:** CONTEXT chose Option C: one logo and two burn animations created once, then **copies** passed to pCnt1, pMenu, pBuy. No shared ownership. Blocker: copyability of `StaticImage`/`Animation` is unclear; alternative is multiple instances.

**Options:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **2A. Copy semantics** | Implement or verify copy constructors for `StaticImage` and `Animation`; create one logo and two burns, then pass copies into each controller (e.g. via AddOwned* with `std::make_unique<T>(original)` or by value if the API accepts it). | Matches CONTEXT "pass copies"; single creation site. | Copy may be expensive or undefined if types hold non-copyable state (e.g. image sequence refs, timers); must audit. |
| **2B. Multiple instances** | Create three separate logos and six burns (two per controller); each controller gets its own via AddOwned* (or AddV(unique_ptr) if we keep owned path). | No copyability required; clear ownership per controller. | More creation code; must keep TRIAL/FULL and positions/state in sync; some duplication. |
| **2C. One instance, non-owned registration** | Create one logo and two burns in DGC (e.g. unique_ptr); register them with pCnt1, pMenu, pBuy via **raw** AddV/AddE (or GetNonOwned*). So "Option C" is relaxed to "no shared **ownership**" but shared **instance**. | Single creation; no copyability. | Controllers don't own the visuals; lifetime must be guaranteed by DGC (same as SoundControls). CONTEXT said "pass copies"; this deviates to shared instance. |
| **2D. Hybrid** | Use **2B** for burn (multiple instances, simpler state) and **2A** or **2C** for logo (one or three copies). | Can optimize per-type. | Two strategies to maintain. |

**Recommendation:** Try **2A** first (audit copyability; if safe, use copies). If not safe, **2B** is the safest; **2C** is acceptable if CONTEXT is updated to "single instance, raw in lists, DGC owns."

**Chosen:** **2A.** Copy semantics. Create once, pass copies to pCnt1, pMenu, pBuy; each controller owns its copy. StaticImage and Animation must be copyable.

---

## 3. SoundControls (one owner, many consumers)

**Problem:** DGC should own two `SoundControls` (unique_ptr); many controllers receive raw pointers. Blocked by the same AddE/list design as §1.

**Options:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **3A. After §1** | Once raw registration exists (1A or 1B), DGC holds `std::unique_ptr<SoundControls> pBckgMusic_, pNoMusic_`; pass `pBckgMusic_.get()` to AddE(...) or AddENonOwned(...); LevelController::pSc = pBckgMusic_.get(). | Matches CONTEXT; no extra design. | Depends on §1. |
| **3B. GetNonOwned only** | Each controller that needs SoundControls overrides `GetNonOwnedUpdateEntities` and returns DGC's SoundControls*. DGC must expose them (e.g. getters). | No AddE change. | Same as 1D: many overrides and wiring. |

**Recommendation:** **3A** — resolve §1, then SoundControls migration is straightforward.

**Chosen:** **By value (copies).** Make copies of SoundControls and pass a copy into each controller that needs one. Each controller **owns** its copy (e.g. AddOwnedEventEntity). No DGC ownership of SoundControls for other screens. SoundControls must be copyable.

---

## 4. Scope and interdependencies (execution strategy)

**Problem:** Many entities and controllers; TRIAL/FULL; risk of use-after-free or double delete if ownership is wrong.

**Options:**

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **4A. One PR: list design first, then DGC** | (1) Implement chosen list/AddV/AddE design (1A or 1B); update all Phase 3 call sites that currently use AddV/AddE for DGC-owned or single-owned entities; run build + ctest + simulation_test. (2) Then do DGC StartUp: SoundControls, logo/burn, remaining entities in order; test after each logical step. | Clear ordering; list design is the single big change; DGC is then mechanical. | First step is still large if 1A. |
| **4B. Incremental by controller** | Migrate one controller at a time (e.g. StartScreenController first: logo, SoundControls for pCnt1 only) using GetNonOwned* only; then next controller; finally introduce raw lists if we want to consolidate. | Small steps; low risk per step. | Proliferation of GetNonOwned* overrides; may later refactor to 1A/1B anyway. |
| **4C. Changelist checklist** | Before coding, write a checklist: every entity in StartUp, owner, and registration (AddOwned* vs raw). Implement list design, then DGC following the checklist; test TRIAL and FULL. | Reduces "who owns what" mistakes. | Same as 4A with an explicit checklist. |

**Recommendation:** **4A** or **4C**; **4C** if the checklist is shared (e.g. in plan or CONTEXT) so executor and reviewer can verify.

---

## Chosen approach (summary)

- **§1:** **1D for MenuController only.** Only MenuController and LevelController override GetNonOwned*. Simple controllers do not; they get copies and own them.
- **§2:** **2A.** Logo and burn: copy semantics; each controller owns its copy.
- **§3:** **By value.** SoundControls: make copies; each controller owns its copy.
- **Preference:** When one object is passed to multiple places, prefer making a copy; controllers own the object.

No list/AddV/AddE redesign required for Task 1.2: simple controllers receive owned copies (AddOwned*); MenuController/LevelController continue to use GetNonOwned* only for caret and tutorial text.

---

## How the options work together

- **Unblock order:** Resolve **§1** first (choose 1A or 1B). That unblocks **§3** (SoundControls) and enables **§2** (logo/burn) to be delivered via raw registration (2C) or via copies into the same registration path (2A/2B).
- **Option C (§2):** If you choose **2C** (shared instance, raw in lists), CONTEXT should be updated to say "DGC owns logo and burn; controllers receive raw; no copies." Then §2 and §1 align without requiring copyability.
- **Phase 4:** If you choose **1B** (non-owned lists), Phase 4 can keep using `AddV`/`AddE` with smart_pointer until Phase 4 migration; then switch to raw + 1A-style or keep 1B.

---

## Suggested path (short) — with chosen options

1. **No list redesign.** Simple controllers get copies and own them (AddOwned*); only MenuController and LevelController use GetNonOwned* (caret, tutorial text).
2. **Logo/burn (2A):** Audit copyability for StaticImage and Animation; implement or fix copy constructors; create once, pass copies to pCnt1, pMenu, pBuy; each adds via AddOwned*.
3. **SoundControls (by value):** Ensure SoundControls is copyable; create one or two "template" instances in StartUp, then make a copy per controller and pass via AddOwnedEventEntity (or AddOwnedBoth); each controller owns its copy.
4. **Execution:** Use **4C** (checklist of entity to owner to registration); run build, ctest, simulation_test after each step; test both TRIAL and FULL.

---

*Next:* Create or update the execution plan for Task 1.2 (03-01.2 plan). CONTEXT and chosen options are in 03-CONTEXT.md and above.
